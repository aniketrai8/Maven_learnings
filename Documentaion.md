# Maven & Gradle

### Both are a project Management tool, Helps developers in
> Dependency Resolution</br>
> Build Generation</br>
> Documentation</br>


## POM _ Project object Model
It helps to organize and manage software development process

As the project progresses sometimes you need to update the dependencies which we dont need to do manually it can be
automatically done by Maven.

Popular Features of Maven ->
> Dependency Mangement</br>
> Project Standardization</br>
> Build Automation</br>
> Plugin system</br>
> Consistent build</br>
> Seamless Integration with IDE</br>

## Annotation in Maven ->
 - Dependency
 - plugin
 - compile, test, package
 



## Maven Default Lifecycle
### Program Lifecycle

1. **Initialization**
   - Load dependencies
   - Set up configurations

2. **Execution**
   - Run the `main()` method
   - Perform calculations or logic

3. **Logging**
   - Application logs messages (INFO, WARN, ERROR)

4. **Termination**
   - Program exits gracefully
   - Resources are released


## Basic Commands 
<I>Compiles source code for the project</I>
* mvn clean - Cleans the project and removes all the files generated by previous builds
+ mvn compile - Compiles source code of the project
- mvn test - Runs Test for the project
+ mvn test-compile 
- mvn package - Creates the JAR or WAR files for the project to convert it into a distributable format
* mvn install - Deploys the packages JAR/WAR files inside the repository
- mvn site- generates the project documentation

<b><I>One of the first step is to define the dependencies</I></b> 
```Dependency
<dependencies>
   <dependency>
     <groupId>org.springFramework</groundId>
     <artifactId>spring-core</artifactId>
     <versions>5.3.8</versions>
   <dependency>
 </dependencies>
```

 ### Second Step is to resolve Dependency conflicts ->
So post dependencies are stated in pom.xml file. 

Maven will automatically download and resolve dependencies from central repository and it will first check if the dependencies are already within the repos

> Managing Dependencies <br>
 Managing Dependencies involve including<br>
 1. **Adding**<br>
 2. **Removing**<br>
 3. **Updating dependencies**. <br>

> Compile dependency<br> 
- These are provided to succesfully compile the dependency, these are packed in project
                      output or jar file

> Provided Dependency<br>
* These are expected to be provided by the runtime enviroment, examples of such dependencies
are severlets.api and p.api

> Runtime Dependencies -> <br>
* Runtime dependenciesa are provided as their name suggests and are kept outside the JAR
files

> Test Dependencies -> <br>
* Are required at the time of Test

 -------------------------------------------------------------------------------------------------

 # GRADLE

### Gradle basic needs is that there are number of parts of developing a full scale Java project to be delievered to the client, it involves

* Devloping Source Code
* Compiling the code
* Adding libraries/jar files to the classpath
* Creating Projects standard directories
* Generating documents
* Building Jar/War files
* Unit Testing
* Deployment

  -----------------------------
  
<I>So any of this might brake at any point and that might lead to causing an error delay in delivvering the project to the client in order to reduce time and projet<I>
Dependencies mangement and lifecyle issuses
A <b>BUILD</b> automation tool like Gradle was introduced, to manage the effectively the entire cycle and speed up the whlole process and Automate the same.

# Mockitwo

  Mockitwo is used for Unit Testing it major feathure inlcude
  * Creating Mock objects to simulate the behaviour of Dependencies
  * It helps isolate the class under test so it can indepependenttly tested
  * The real objective is to replace the real objects during the Tests.

### Annotation
* Mock -> Creates a mock object
* InjectMocks -> Creates an Object and injects mocks into it
* @Spy -> Wraps a real object and lets you stub some methods
* @ Captor -> Captures argument passed to a mocked method

  ```
  public class UserServiceTest {
  @Mock
  private UserRepository repo;

  @InjectMocks
  private UserService service;

  @Test
  public void testGetUser(){
   when (repo.findById(1)).thenReturn(new User(1,"John"));
  assertEquals("John", user.getName());
  }
  }
  ```
  * Stubbing -> Telling a mock what to return when a method is called.
  * Verification -> Checking that a method was called.
 
    
