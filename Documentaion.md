# Maven & Gradle

### Both are a project Management tool, Helps developers in
> Dependency Resolution</br>
> Build Generation</br>
> Documentation</br>


## POM _ Project object Model
It helps to organize and manage software development process

As the project progresses sometimes you need to update the dependencies which we dont need to do manually it can be
automatically done by Maven.

Popular Features of Maven ->
> Dependency Mangement</br>
> Project Standardization</br>
> Build Automation</br>
> Plugin system</br>
> Consistent build</br>
> Seamless Integration with IDE</br>

## Annotation in Maven ->
 - Dependency
 - plugin
 - compile, test, package
 



## Maven Default Lifecycle
### Program Lifecycle

1. **Initialization**
   - Load dependencies
   - Set up configurations

2. **Execution**
   - Run the `main()` method
   - Perform calculations or logic

3. **Logging**
   - Application logs messages (INFO, WARN, ERROR)

4. **Termination**
   - Program exits gracefully
   - Resources are released


## Basic Commands 
<I>Compiles source code for the project</I>
* mvn clean - Cleans the project and removes all the files generated by previous builds
+ mvn compile - Compiles source code of the project
- mvn test - Runs Test for the project
+ mvn test-compile 
- mvn package - Creates the JAR or WAR files for the project to convert it into a distributable format
* mvn install - Deploys the packages JAR/WAR files inside the repository
- mvn site- generates the project documentation

<b><I>One of the first step is to define the dependencies</I></b> 
```Dependency
<dependencies>
   <dependency>
     <groupId>org.springFramework</groundId>
     <artifactId>spring-core</artifactId>
     <versions>5.3.8</versions>
   <dependency>
 </dependencies>
```

 ### Second Step is to resolve Dependency conflicts ->
So post dependencies are stated in pom.xml file. 

Maven will automatically download and resolve dependencies from central repository and it will first check if the dependencies are already within the repos

> Managing Dependencies <br>
 Managing Dependencies involve including<br>
 1. **Adding**<br>
 2. **Removing**<br>
 3. **Updating dependencies**. <br>

> Compile dependency<br> 
- These are provided to succesfully compile the dependency, these are packed in project
                      output or jar file

> Provided Dependency<br>
* These are expected to be provided by the runtime enviroment, examples of such dependencies
are severlets.api and p.api

> Runtime Dependencies -> <br>
* Runtime dependenciesa are provided as their name suggests and are kept outside the JAR
files

> Test Dependencies -> <br>
* Are required at the time of Test

 -------------------------------------------------------------------------------------------------

 # GRADLE
* Gradle is  a Groovy based build mangement tool deisgned specically for Java Based Project.
<I> What is a Gradle do </I> ?
  - A project in gradle can be assembling a jar,war or even .zip file.
<I> What is a task in Gradle </I> ?
 - A Task is a single peice of work. This can include compiling classes or creating and publishing Java/Web archives.
### Gradle basic needs is that there are number of parts of developing a full scale Java project to be delievered to the client, it involves

* Devloping Source Code
* Compiling the code
* Adding libraries/jar files to the classpath
* Creating Projects standard directories
* Generating documents
* Building Jar/War files
* Unit Testing
* Deployment

  -----------------------------
  
<I>So any of this might brake at any point and that might lead to causing an error delay in delivvering the project to the client in order to reduce time and projet<I>

## <ins>Tasks</ins>
```
 task toLower {
   doLast {
    String someString =' hello from Baeludnung'
    println "Original: "+ someString
        println "Lower case: " + someString.toLowerCase()
    }
}
```
<I> Adding Behaviour to a Task </I>
```
task helloAniket {
  doLast {
   println 'I will be executed second '
}

helloAniket.doFirst {
   println 'I will be executed first '
}
helloAniket.doLast {
   println 'I will be executed third'
}

helloAniket {
doLast {
   println 'I will be executed fourth'
}
```

<B>  <ins> Plugins</ins> </B>
<i> Plugins are a resuable peiece of build logic that adds tasks,conventions or confriguation to your project, so instead of repeating build code again and again you package it as a Plugin. </I>
* There are two tupes of plugins in Gradle - <I>script and binary</I>
* To beneift from adding additional functionality, every plugins needs to go through both <ins>resolving and applying</ins>.
 > Resolving - Resolving means finding the correct verions of the plugin jar and adding to the classpath of the project.
 > Applying Plugins - Applying plugins means executing Plugin.apply(T) on the project.
```
task fromPlugin {
  doLast {
     println "I'm from plugin"
   }
}

To Apply
apply from: 'aplugin.gradle'

```
<b> Script Plugin </b>
* These are .gradle files that you can include into another build script.
  ```
  repositories {
     mavenCentral() {
  }

  dependencies {
     testImplementation 'junit:junit:4.13.2'
  }

  //build.gradle
  apply from 'common.gradle'
  ```
<b>Binary Plugins</b> ->
* Should be declared at the top of build.gradle file before you declare repositories and dependencies.
* Plugin DSL <b>cannot</b> be used at the <I>gradle.init, setting.gradle</I> as these are processed at a different stage of the Gradle    Lifecycle, the plugins DSL is avaliable at the project level (only can be written in build.gradle pr build.gradle.kts) and it is not avaliable  at the build setup or intialization phase.
* Binary Plugin is only added in .class or .jar file
* <ins> These are proper compiled plugins - written in Java(etc) as .jar files
```
package com.example

import org.gradle.Plugin;
import org.gradle.api.Project;

public class MyPlugin implements Plugins<Project> {
@Override
public void apply (Project project) {
  proejct.task("helloPlugin").doLast(taslk-> {
    System.out.println("Hello from my Binary Plugin");
  });
}
}

plugins {
   id 'com.example.myplugin' version '1.0'
} 

```
<ins> Custom Tasks </ins>
* Cutoms tasks are the ones where simply you define your own specific action.
* Cutoms Tasks can -
  > Run Shell Commands
  > Process Files
  > Generate Code
  > Deploy artificats
* Examples of Cutom tasks include <ins>@doLast</ins>, <ins>@doFirst</ins>, <ins>@dependsOn</ins> , <ins>@TaskAction</ins>
  ```
  tasks.register('taskName') {
   group = 'Custom'
  description = 'Does an Activity"
  dependsOn = ' otherTask'

  doFirst {
    println ' Runs before the main action'
  }
  doLast {
    println 'Runs in the end'
  }
  }
  ```
### <ins>Dependencies mangement and lifecyle issuses</ins>
A <b>BUILD</b> automation tool like Gradle was introduced, to manage the effectively the entire cycle and speed up the whlole process and Automate the same.



# Mockitwo

  Mockitwo is used for Unit Testing it major feathure inlcude
  * Creating Mock objects to simulate the behaviour of Dependencies
  * It helps isolate the class under test so it can indepependenttly tested
  * The real objective is to replace the real objects during the Tests.

### Annotation
* Mock -> Creates a mock object
* InjectMocks -> Creates an Object and injects mocks into it
* @Spy -> Wraps a real object and lets you stub some methods
* @ Captor -> Captures argument passed to a mocked method

  ```
  public class UserServiceTest {
  @Mock
  private UserRepository repo;

  @InjectMocks
  private UserService service;

  @Test
  public void testGetUser(){
   when (repo.findById(1)).thenReturn(new User(1,"John"));
  assertEquals("John", user.getName());
  }
  }
  ```
  * Stubbing -> Telling a mock what to return when a method is called.
  * Verification -> Checking that a method was called.
 
    
